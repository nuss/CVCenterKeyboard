TITLE:: CVCenterKeyboard
summary:: A MIDI keyboard implementation for CVCenter
categories:: Conductor>CVCenter, External Control>MIDI
related:: Classes/CVCenter, Guides/UsingMIDI, Classes/CVCenterKeyboardSampler

DESCRIPTION::
A CVCenterKeyboard consists of a collection of SynthDefs and provides a convenient way to play them on a MIDI keyboard.

CVCenterKeyboard lets you create a link::Guides/UsingMIDI#Playing notes on your MIDI keyboard#MIDI keyboard:: layout instantly from any SynthDef that provides a code::\gate:: key, meaning that a Synth that has been instiated upon receiving a note-on message gets finished when it gets a not-off message from an external MIDI keyboard. That allows for playing sustained notes that can be controlled through code::asr:: or code::adsr:: envelopes. A SynthDef with a "gated" envelope should answer code::true:: on executing the following line:

code::
SynthDescLib.at(yourSynthDefName).hasGate;
::

Beyond the just explained procedure you may add an arbitrary number of other SynthDefs. You may switch between these SynthDefs by calling link::#-setSynthDef::. Playing the keyboard should immediately play generated nodes using the selected SynthDef.

Setting up the keyboard basically involves two steps: First instantiating a keyboard (through link::#-new:: or link::#-newSynthDef::) and then setting up the keyboard for a given SynthDef through link::#-setUpControls:: (will start the Server).

You can assign four arbitray controls from your SynthDef to the following standard parameters:

DEFINITIONLIST::
## outControl
|| the arg that sets the output bus of the Synth
## keyboardControl
|| whatever you want to play with your keyboard (e.g. Frequency). You'll get midi notes back
## velocControl
|| whatever you want to control through keyboard velocity
## bendControl
|| whatever you want to control through the pitch bend wheel (the internal control will automatically assigned a spec code::ControlSpec(0.midicps.neg, 0.midicps, \lin, 0, 0, " hz")::)
::

All other controls you may have defined in your SynthDef will automatically be picked up by the setup process and get assigned appropriate widgets automatically.

NOTE:: Differently to normal usage within CVCenter the Synths (or nodes) created by playing the keyboard are addressed anonymously when setting their controls. I.e. the Synths are not assigned to a variable which serves as the reference to the Synth when setting a control. That means you can use controls of the same name within more than one SynthDef and they will be considered within every playing Synth. However, you should think about the Specs for your controls beforehand. E.g. if you have an argument code::\freq:: in two different SynthDefs and one should have a range of 20-20000 and the other one 20-4000 the range of the argument that has been created first will take precendence over the second one (there can only be one widget named code::\freq:: in CVCenter).
::

Additionally an output proxy - a link::Classes/NodeProxy:: or an link::Classes/Ndef:: - can be added through link::#-addOutProxy:: which allows you to build an effects chain and to do other kinds of NodeProxy trickery.

CLASSMETHODS::

METHOD:: new
Instanciate a new keyboard under code::keyboardName::. The keyboard will be accessible under code::CVCenterKeyboard.all[keyboardName]::
argument:: keyboardName
a link::Classes/String:: or link::Classes/Symbol::, denoting the name of the new keyboard
argument:: srcID
Optional - an link::Classes/Integer:: corresponding to the unique ID of the MIDI device. If omitted the keyboard will be usable on any currently connected MIDI keyboard. To find out the unique numeric ID of your MIDI device you could use thefollowing code:
code::
MIDIClient.init;
MIDIClient.sources.do { |source| [source, source.uid].postln };
::
(See also: link::Guides/UsingMIDI#MIDIFunc and MIDIdef: Filtering based on device or message data::)
argument:: chan
Optional - an link::Classes/Integer:: denoting the MIDI channel the keyboard should use. If omitted the keyboard can be played on any MIDI channel (See also: link::Guides/UsingMIDI#MIDIFunc and MIDIdef: Filtering based on device or message data::)
argument:: addSampler
Optional - this argument will be set to code::true:: by default and adds a sampler that records all keystrokes on the keyboard upon calling link::-sample::. Calling link::-sample:: again will stop recording and the just recorded sequence will immediately start playing. See link::Classes/CVCenterKeyboardSampler:: for more information on the recording mechanism and the structure of the recorded sequences.

METHOD:: newSynthDef
Instantiate a new CVCenterKeyboard holding the SynthDef denoted by code::synthDefName::. The SynthDef must have beem compiled in advance.
argument:: synthDefName
A link::Classes/Symbol:: or a link::Classes/String:: denoting the link::Classes/SynthDef:: that should be added to the keyboard. Note that the SynthDef strong::must:: have a gated envelope (i.e. executing code::SynthDescLib.at(synthDefName).hasGate:: must return code::true::. code::synthDefName:: must be given as code::Symbol:: to return the expected result. See link::Classes/EnvGen:: for an explanation of how to create an envelope with a gate).
argument:: keyboardDefName
a link::Classes/String:: or link::Classes/Symbol::, denoting the name of the new keyboard
argument:: srcID
Optional - an link::Classes/Integer:: corresponding to the unique ID of the MIDI device. If omitted the keyboard will be usable on any currently connected MIDI keyboard. See link::#-new:: for how to determine the unique ID of your MIDI device.
(See also: link::Guides/UsingMIDI#MIDIFunc and MIDIdef: Filtering based on device or message data::)
argument:: chan
Optional - an link::Classes/Integer:: denoting the MIDI channel the keyboard should use. If omitted the keyboard can be played on any MIDI channel (See also: link::Guides/UsingMIDI#MIDIFunc and MIDIdef: Filtering based on device or message data::)
argument:: addSampler
Optional - this argument will be set to code::true:: by default and adds a sampler that records all keystrokes on the keyboard upon calling link::-sample::. Calling link::-sample:: again will stop recording and the just recorded sequence will immediately start playing. See link::Classes/CVCenterKeyboardSampler:: for more information on the recording mechanism and the structure of the recorded sequences.

METHOD:: at
A simple convenience method, same as code::CVCenterKeyboard.all[keyboardDefName]:: except for the fact that code::keyboardDefName:: can be given as link::Classes/String:: as well (will be converted to a link::Classes/Symbol:: internally).
argument:: keyboardDefName
A link::Classes/String:: or link::Classes/Symbol:: denoting the name of the CVCenterKeyboard instance.
returns:: The CVCenterKeyboard instance under the given name if it exists or code::nil::.

METHOD:: all
returns:: an link::Classes/Event::, containing all CVCenterKeyboard instances.

INSTANCEMETHODS::

METHOD:: addSynthDef
Add a new link::Classes/SynthDef:: to an existing CVCenterKeyboard instance. The SynthDef must already have been compiled and contain a gated envelope.
argument:: synthDefName
A link::Classes/String:: or an link::Classes/Symbol::, denoting the name of the SynthDef.

METHOD:: setUpControls
Whenever a new SynthDef is added, either by creating a new instance by calling code::CVCenter.Keyboard.newSynthDef:: or adding a SynthDef with link::-addSynthDef::, the CVCenterKeyboard instance must be set up for the new SynthDef. This will configure code::outControl::, code::keyboardControl:: and code::bendControl:: as well as it will create link::Classes/CVWidget::s for all other controls in the SynthDef.
argument:: synthDefName
The link::Classes/SynthDef::'s name, given as link::Classes/Symbol:: or link::Classes/String::
argument:: prefix
An optional link::Classes/Symbol:: or link::Classes/String:: for link::Classes/CVCenter::, to make sure the resulting widgets get a unique name.
argument:: pitchControl
A link::Classes/Symbol:: or link::Classes/String:: denoting the keyboard key, incoming note. Default: code::\freq::.
argument:: velocControl
A link::Classes/Symbol:: or link::Classes/String:: denoting velocity coming with the note. Default: code::\veloc::.
argument:: bendControl
A link::Classes/Symbol:: or link::Classes/String:: denoting the control to be set by the pitch bend wheel. Default: code::\bend::.
argument:: outControl
A link::Classes/Symbol:: or link::Classes/String:: denoting the output bus. Default: code::\out::.
argument:: includeInCVCenter
An link::Classes/Array:: of link::Classes/Symbol::s or link::Classes/String::s, denoting those of the before described arguments which emphasis::should:: appear in link::Classes/CVCenter:: though they have already been assigned to the keyboard.
argument:: theServer
Optional - the link::Classes/Server:: to run the link::Classes/Synth::s on produced with every keystroke.
argument:: outbus
Optional - an link::Classes/Integer:: denoting a default output bus (can be set in the SynthDef beforehand as well).
argument:: deactivateDefaultWidgetActions
When link::Classes/CVWidget::s are created from a running code::Classes/Synth:: these widgets will be added default actions to set the regarding controls in the Synth, which is not desirable in this case. However, actions will just get deactivated and can get re-activated at any time. Default: code::true::.
argument:: tab
Optional - a link::Classes/Symbol:: or link::Classes/String:: denoting the tab in which the link::Classes/CVWidget::s for the link::Classes/Synth:: instances will appear. If none is given the tab name will default the the SynthDef's name.
argument:: setSynthDef
A link::Classes/Boolean::. If set to code::true:: the CVCenterKeyboard instance can be played using the given link::Classes/SynthDef:: immediately (otherwise you will have to call link::-setSynthDef:: explicitly). Default: code::false::.

DISCUSSION::

code::
// define SynthDef with a gated envelope
(
SynthDef(\multi, {
    var env = EnvGen.ar(
		Env.adsr(\atk.kr(0.01), \dec.kr(0.3), \sust.kr(0.5), \rel.kr(0.7)),
		\gate.kr(1), // we need a gated envelope!
		doneAction: Done.freeSelf // free the Synth when done
	);
	var freq = \freq.kr(220);
	var son = [SinOsc.ar(freq), Saw.ar(freq), Pulse.ar(freq)];
	var which = SelectX.ar(\which.kr(0!2) * son.size, son); // stereo select
	Out.ar(\out.kr(0), which * \veloc.kr(1) * \amp.kr(0.5) * env);
}).add
)

// a few specs for the controls
// specs with the same name as the regarding control
// will automatically be assigned to the control in CVCenter
(
Spec.add(\atk, #[0.01, 1.0], \exp);
Spec.add(\dec, #[0.1, 2.0]);
Spec.add(\sust, #[0.1, 1.0]);
Spec.add(\rel, #[0.1, 2.0, \exp]);
Spec.add(\which, #[0, 2]);
)

// create new keyboard, using pre-defined SynthDef
// will initialize MIDI and open CVCenter
~kb = CVCenterKeyboard.newSynthDef(\multi, \myKeyboard);

// set up controls and add CVWidgets for Synth controls
// this will boot the server and open a dialog for setting specs
// you will hear a short tone generated from a Synth instance of
// the given SynthDef which is needed by CVCenter to determine
// the Synth controls
(
~kb.setUpControls(
	\multi, // the SynthDef
    \kb, // a prefix for CVCenter, should make shure the resulting widgets have a unique names
    \freq, // the pitch argument, to be controlled through the MIDI keyboard keys
    \veloc, // the velocity argument
    \freq, // the bend argument - will often be the same as the pitch argument
    \out, // the argument setting the out bus
	setSynthDef: true // start keyboard using the given SynthDef immediately
)
)

// play some notes on your keyboard...
::

METHOD:: setSynthDef

argument:: synthDefName

METHOD:: wdgtName

METHOD:: off

METHOD:: on

METHOD:: free
argument:: synthDefName

METHOD:: synthParams

METHOD:: unmapBus
argument:: ctrlname

METHOD:: pdef

METHOD:: onFunc

METHOD:: sampler

METHOD:: mapBus
argument:: ctrlname
argument:: bus

METHOD:: clear
argument:: synthDefName

METHOD:: createSelect
argument:: tab

METHOD:: init
argument:: srcID
argument:: chan
argument:: addSampler

METHOD:: namesCVs

METHOD:: addSampler

METHOD:: offFunc

METHOD:: debug

METHOD:: out

METHOD:: removeOutProxy
argument:: synthDefName
argument:: outbus

METHOD:: bendSpec

METHOD:: bend

METHOD:: currentSynthDef

METHOD:: pairs

METHOD:: server

METHOD:: outProxy

METHOD:: valuePairs

METHOD:: removeSynthDef
argument:: synthDefName

METHOD:: freeHangingNodes

METHOD:: group

METHOD:: wdgtNames

METHOD:: keyboardDefName

METHOD:: mappedBusses

METHOD:: sample
argument:: onOff

METHOD:: synthDefNames

METHOD:: bendFunc

METHOD:: select

METHOD:: addOutProxy
argument:: synthDefName
argument:: numChannels
argument:: useNdef
argument:: transbus
argument:: outbus
argument:: play


EXAMPLES::

code::
_some_example_code_
::

PRIVATE:: initClass, prAddWidgetActionsForKeyboard, prEnvInit, prInitCVs, prInitSynthDef, prInitKeyboard
