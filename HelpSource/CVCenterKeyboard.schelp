TITLE:: CVCenterKeyboard
summary:: A MIDI keyboard implementation for CVCenter
categories:: Conductor>CVCenter, External Control>MIDI
related:: Classes/CVCenter, Guides/UsingMIDI

DESCRIPTION::
CVCenterKeyboard lets you create a link::Guides/UsingMIDI##MIDI keyboard:: layout instantly from any SynthDef that provides
a code::\gate:: key, meaning that a Synth that has been instiated upon receiving a note-on message
gets finished when it gets a not-off message from an external MIDI keyboard. That allows for playing sustained notes that
can be controlled through code::asr:: or code::adsr:: envelopes.

Seting up the keyboard basically involves to steps: First instantiating a keyboard
(through link::#-new:: or link::#-newSynthDef::) and then setting up the keyboard
for a given SynthDef through link::-setUpControls:: (will start the Server).

You can assign four arbitray controls from your SynthDef to the following standard parameters

DEFINITIONLIST::
## outControl
|| the arg that sets the output bus of the Synth
## keyboardControl
|| what ever you want to play with your keyboard (e.g. Frequency). You'll get midi notes back
## velocControl
|| whatever you want to control through keyboard velocity
## bendControl
|| whatever you want to control through the pitch bend weal (the internal control
	will automatically assigned a spec code::ControlSpec(0.midicps.neg, 0.midicps, \lin, 0, 0, " hz")::)
::

Especially after loading an already existing CVCenter setup you possibly have to re-init the keyboard through link::-reInit::

Additionally an output proxy - a link::Classes/NodeProxy:: or an link::Classes/Ndef:: - can be added through link::-addOutProxy:: which allows you to do filtering and all kinds of NodeProxy trickery.
First code examples:

code::
(
SynthDef(\pmosc, {
	var env = Env.adsr(\atk.kr(0.01), \dec.kr(0.3), \sust.kr(0.5), \rel.kr(0.7));
	var son = PMOsc.ar(
		\carfreq.kr(100),
		\modfreq.kr(300!2, 0.02),
		\pmindex.kr(0!2, 0.02),
		\modphase.kr(0!2, 0.02)
	);
	env = EnvGen.ar(env, \gate.kr(1), doneAction: Done.freeSelf);
	Out.ar(\out.kr(0), son * \veloc.kr(1) * \amp.kr(0.5) * env);
}).add;
)

// set a couple of useful specs ahead from keyboard creation
(
Spec.add(\atk, #[0.01, 1.0]);
Spec.add(\dec, #[0.1, 2.0]);
Spec.add(\sust, #[0.1, 1.0]);
Spec.add(\rel, #[0.1, 2.0, \exp]);
Spec.add(\carfreq, #[40, 2000, \exp]);
Spec.add(\modfreq, #[40, 2000, \exp]);
Spec.add(\pmindex, #[0, 30]);
Spec.add(\modphase, \phase);
)

//
~kb = CVCenterKeyboard.newSynthDef(\pmosc, \myKeyboard);
~kb.setUpControls(\pmosc, \kb, \out, \carfreq, \veloc, \carfreq);
// just in case, won't do no harm
~kb.reInit(\pmosc);
~kb.addOutProxy(useNdef: true);
::

CLASSMETHODS::

METHOD:: all

METHOD:: new
argument:: name

METHOD:: newSynthDef
argument:: synthDefName
argument:: connectMidi
argument:: keyboardName

METHOD:: initClass

METHOD:: at
argument:: keyboardName


INSTANCEMETHODS::

METHOD:: currentSynthDef

METHOD:: clearSamples
argument::  ... indices

METHOD:: prResetSampling

METHOD:: addOutProxy
argument:: synthDefName
argument:: numChannels
argument:: useNdef

METHOD:: synthDefNames

METHOD:: reInit
argument:: synthDefName

METHOD:: switchKeyboard
argument:: synthDefName

METHOD:: addSynthDef
argument:: synthDefName
argument:: connectMidi

METHOD:: out

METHOD:: controls

METHOD:: prInitCVs
argument:: synthDefName
argument:: args

METHOD:: init

METHOD:: setUpControls
argument:: synthDefName
argument:: prefix
argument:: outControl
argument:: keyboardControl
argument:: velocControl
argument:: bendControl
argument:: theServer
argument:: out
argument:: deactivateDefaultWidgetActions
argument:: srcID
argument:: tab

METHOD:: bendSpec

METHOD:: pdef

METHOD:: initSynthDef
argument:: synthDefName
argument:: connectMidi
argument:: keyboardName

METHOD:: removeOutProxy
argument:: synthDefName
argument:: out

METHOD:: debug

METHOD:: sample

METHOD:: activateSampling
argument:: onOff
argument:: synthDefName

METHOD:: prAddWidgetActionsForKeyboard
argument:: synthDefName
argument:: deactivateDefaultActions

METHOD:: prInitKeyboard
argument:: synthDefName

METHOD:: server

METHOD:: name

METHOD:: wdgtNames

METHOD:: outProxy

METHOD:: free
argument:: synthDefName

METHOD:: sampleEvents

METHOD:: prMidiInit
argument:: synthDefName
argument:: connectMidi

METHOD:: prDurSum
argument:: durs


EXAMPLES::

code::
_some_example_code_
::
